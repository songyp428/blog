{"remainingRequest":"/Users/yanping/Documents/songyp/blog/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/yanping/Documents/songyp/blog/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/yanping/Documents/songyp/blog/docs/fe/js/arrayDeduplication.md?vue&type=template&id=9b17b686&","dependencies":[{"path":"/Users/yanping/Documents/songyp/blog/docs/fe/js/arrayDeduplication.md","mtime":1560934369000},{"path":"/Users/yanping/Documents/songyp/blog/node_modules/cache-loader/dist/cjs.js","mtime":1560934370000},{"path":"/Users/yanping/Documents/songyp/blog/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1560934372000},{"path":"/Users/yanping/Documents/songyp/blog/node_modules/cache-loader/dist/cjs.js","mtime":1560934370000},{"path":"/Users/yanping/Documents/songyp/blog/node_modules/vue-loader/lib/index.js","mtime":1560934372000},{"path":"/Users/yanping/Documents/songyp/blog/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1560934372000}],"contextDependencies":[],"result":["\n<div class=\"content\"><h3 id=\"数组去重\"><a class=\"header-anchor\" href=\"#数组去重\" aria-hidden=\"true\">#</a> 数组去重</h3>\n<h4 id=\"_1、双重循环\"><a class=\"header-anchor\" href=\"#_1、双重循环\" aria-hidden=\"true\">#</a> 1、双重循环</h4>\n<blockquote>\n<p>第一层循环是需要去重的 array<br>\n第二层循环是存放没有重复的元素的临时 array (初始化为空数组)<br>\n关键点我理解有两点：<br>\n1、如果存在相等（ 全等哦，=== ）则跳出第二层循环<br>\n2、如果第二层循环 index: j 的值与 tmpArr 的长度 length 相等，则存到 tmpArr</p>\n</blockquote>\n<p><strong>注意： 对象和 NaN 不去重。</strong></p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var a = [1, 1, 2, 3, 2, &#39;1&#39;, true, &#39;1&#39;, &#39;2&#39;, 1, false, true, null, null, undefined, undefined, NaN, NaN]\n\nfunction getUniqueArray(arr){\n\tlet j\n\tlet tmp_len\n\tlet tmpArr = []\n\n\tfor (let i = 0,len_i = arr.length; i &lt; len_i; i++ ) {\n\t\tfor (j = 0,tmp_len = tmpArr.length; j &lt; tmp_len; j++ ) {\n\t\t\t//注意是 === \n\t\t\tif (arr[i] === tmpArr[j]) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\n\t\t//j === tmp_len,则说明没有找到相同值\n\t\tif (j === tmp_len) {\n\t\t\ttmpArr.push(arr[i])\n\t\t}\n\t}\n\n\treturn tmpArr\n}\n\nconsole.log(getUniqueArray(a))  //[1, 2, 3, &quot;1&quot;, true, &quot;2&quot;, false, null, undefined, NaN, NaN]\n</code></pre>\n<!--beforeend--></div><!--afterend--><h4 id=\"_2、indexof-方法\"><a class=\"header-anchor\" href=\"#_2、indexof-方法\" aria-hidden=\"true\">#</a> 2、indexOf 方法</h4>\n<blockquote>\n<p>借助辅助数组，和 indexOf() 方法，循环一遍需要去重的数组，要执行 n 次 indexOf() 方法，如果数组很大，还是比较耗时。</p>\n</blockquote>\n<p><strong>注意：对象和 NaN 不去重。</strong></p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var a = [1, 1, 2, 3, 2, &#39;1&#39;, true, &#39;1&#39;, &#39;2&#39;, 1, false, true, null, null, undefined, undefined, NaN, NaN]\n\nfunction getUniqueArray(arr) {\n\tvar tmpArr = []\n\n\tfor (let i = 0,len = arr.length; i &lt; len; i++) {\n\t\t//关键点在这里\n\t\tif (!(tmpArr.indexOf(arr[i]) &gt; -1)) {\n\t\t\ttmpArr.push(arr[i])\n\t\t}\n\t}\n\n\treturn tmpArr\n}\n\nconsole.log(getUniqueArray(a)) //[1, 2, 3, &quot;1&quot;, true, &quot;2&quot;, false, null, undefined, NaN, NaN]\n</code></pre>\n<!--beforeend--></div><!--afterend--><h4 id=\"_3、借助-object-键值对\"><a class=\"header-anchor\" href=\"#_3、借助-object-键值对\" aria-hidden=\"true\">#</a> 3、借助 Object 键值对</h4>\n<blockquote>\n<p>第一次写的时候，只是用元素本身作为 object 的 key，但是这样会导致一个问题，例如 1 和 ‘1’ 就是相同的 key,所以需要用元素数据类型和元素作为 key。</p>\n</blockquote>\n<p><strong>特别好，除了对象外都去重了</strong></p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var a = [1,1,&#39;1&#39;,true,&#39;1&#39;,1,false,true,null,null,undefined,undefined,NaN,NaN]\n\nfunction getUniqueArray(arr) {\n\tvar obj = {}\n\tvar tmpArr = []\n\n\tfor (let i = 0,len = arr.length; i &lt; len; i++) {\n\t\tif (!obj.hasOwnProperty(typeof arr[i] + arr[i])) {\n\t\t\tobj[typeof arr[i] + arr[i]] = arr[i]\n\t\t}\n\t}\n\n\ttmpArr = Object.values(obj)\n\n\treturn tmpArr\n}\n\nconsole.log(getUniqueArray(a))  //[1, &quot;1&quot;, true, false, null, undefined, NaN]\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><h4 id=\"_4、数组排序去重\"><a class=\"header-anchor\" href=\"#_4、数组排序去重\" aria-hidden=\"true\">#</a> 4、数组排序去重</h4>\n<blockquote>\n<p>先对需要去重的数组进行排序，如果循环已经排序好的数组，只需要比较当前元素和上一个元素是否相同就好。<br>\n执行效率比使用 indexOf 方法要快。<br>\n如果要求是去重，并且不改变元素本身的相对位置，这种方法就不适用了。</p>\n</blockquote>\n<p><strong>注意：对象和 NaN 不去重 数字 1 也不去重。</strong></p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>//排序循环去重\nvar a = [1,1,2,3,2,&#39;1&#39;,true,&#39;1&#39;,&#39;2&#39;,1,1,false,true,null,null,undefined,undefined,NaN,NaN]\nfunction getUniqueArray(arr) {\n\t// var sortedArr = arr.concat().sort()  //copy,不修改原有数组\n\tvar sortedArr = JSON.parse(JSON.stringify(arr)).sort()  //copy,不修改原有数组\n\n\tvar seen = sortedArr[0]   //赋值已排序数组的第一个元素作为seen\n\tvar tmpArr = [sortedArr[0]]\n\n\tfor (var i = 1, len = sortedArr.length; i &lt; len; i++) {\n\t\tif(seen !== sortedArr[i]) {\n\t\t\ttmpArr.push(sortedArr[i])  //记录不重复的元素\n\t\t\tseen = sortedArr[i]        //更新新的seen\n\t\t}\n\t}\n\n\treturn tmpArr\n}\n\nconsole.log(getUniqueArray(a))\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><h4 id=\"_5、利用-es5-的-filter-简化循环流程\"><a class=\"header-anchor\" href=\"#_5、利用-es5-的-filter-简化循环流程\" aria-hidden=\"true\">#</a> 5、利用 ES5 的 filter 简化循环流程</h4>\n<h5 id=\"辅助-indexof-去重方法\"><a class=\"header-anchor\" href=\"#辅助-indexof-去重方法\" aria-hidden=\"true\">#</a> 辅助 indexOf 去重方法</h5>\n<h4 id=\"_6、借助-es6-一行代码去重\"><a class=\"header-anchor\" href=\"#_6、借助-es6-一行代码去重\" aria-hidden=\"true\">#</a> 6、借助 ES6 一行代码去重</h4>\n<blockquote>\n<p>只针对一维数组，并且对象无法去重。</p>\n</blockquote>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var a = [1,1,2,3,2,&#39;1&#39;,true,&#39;1&#39;,&#39;2&#39;,1,1,false,true,null,null,undefined,undefined,NaN,NaN]\nconsole.log([...new Set(a)])          //[1, 2, 3, &quot;1&quot;, true, &quot;2&quot;, false, null, undefined, NaN]\nconsole.log(Array.from(new Set(a)))   //[1, 2, 3, &quot;1&quot;, true, &quot;2&quot;, false, null, undefined, NaN]\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><h4 id=\"_7、数组元素为对象去重\"><a class=\"header-anchor\" href=\"#_7、数组元素为对象去重\" aria-hidden=\"true\">#</a> 7、数组元素为对象去重</h4>\n<blockquote>\n<p>先来了解一下reduceRight<br>\nreduceRight() : 从数组的末尾向前将数组中的数组项做累加。接收 callbackfn ( function callbackfn ( preValue, curValue, index, array ) ) 函数，而这个函数包含四个参数：<br>\n<strong>preValue</strong>: 上一次调用回调返回的值，或者是提供的初始值（initialValue）。\n<strong>curValue</strong>: 数组中当前被处理的数组项。<br>\n<strong>index</strong>: 当前数组项在数组中的索引值。<br>\n<strong>array</strong>: 调用 reduce()方法的数组。</p>\n</blockquote>\n<blockquote>\n<p>需要根据对象中唯一的 id 来作为唯一标示去重。初始值 initialValue 赋值为空数组（也就是 item 初始时为 [] )，然后判断当前处理元素的 id 是在辅助对象 hash 已有的 key ，不存在则 hash 增加这一条记录，并且把 curValue push 到 preValue 中。</p>\n</blockquote>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var a = [{id: 1,name: &#39;ss&#39;},{id: 2,name: &#39;s&#39;},{id: 3,name: &#39;sss&#39;},{id: 1,name: &#39;ss&#39;},{id: 3,name: &#39;sss&#39;},{id: 4,name: &#39;ssss&#39;}]\n\nvar hash = {}\nvar newArr = a.reduceRight((preValue, curValue) =&gt; {\n    hash[curValue.id] ? &#39;&#39; : (hash[curValue.id] = true &amp;&amp; preValue.push(curValue))\n    return preValue\n}, [])\n\nconsole.log(newArr)  //[{id: 4, name: &quot;ssss&quot;},{id: 3, name: &quot;sss&quot;},{id: 1, name: &quot;ss&quot;},{id: 2, name: &quot;s&quot;}]\n\n</code></pre>\n<!--beforeend--></div><!--afterend--></div>\n",null]}
{"remainingRequest":"/Users/yanping/Documents/songyp/blog/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/yanping/Documents/songyp/blog/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/yanping/Documents/songyp/blog/docs/fe/js/inheritance.md?vue&type=template&id=42bf9ce2&","dependencies":[{"path":"/Users/yanping/Documents/songyp/blog/docs/fe/js/inheritance.md","mtime":1565345674000},{"path":"/Users/yanping/Documents/songyp/blog/node_modules/cache-loader/dist/cjs.js","mtime":1560934370000},{"path":"/Users/yanping/Documents/songyp/blog/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1560934372000},{"path":"/Users/yanping/Documents/songyp/blog/node_modules/cache-loader/dist/cjs.js","mtime":1560934370000},{"path":"/Users/yanping/Documents/songyp/blog/node_modules/vue-loader/lib/index.js","mtime":1560934372000},{"path":"/Users/yanping/Documents/songyp/blog/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1560934372000}],"contextDependencies":[],"result":["\n<div class=\"content\"><h2 id=\"继承方法\"><a class=\"header-anchor\" href=\"#继承方法\" aria-hidden=\"true\">#</a> 继承方法</h2>\n<p>上一篇文章中讨论了原型和原型链，这篇文章主要是来讲一下原型相关的继承。</p>\n<h3 id=\"原型链继承\"><a class=\"header-anchor\" href=\"#原型链继承\" aria-hidden=\"true\">#</a> 原型链继承</h3>\n<p>对象可以通过原型链来继承原型的方法和属性。原型链继承本质：<strong>重写原型对象，代之以一个新类型的实例</strong>。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>function Animal(type) {\n    this.name = &#39;animal&#39;            // 跟子类的属性重名，只能通过 __proto__ 访问\n    this.childs = [&#39;dog&#39;]\n    this.type = type\n}\n\nAnimal.prototype.run = function (){\n\tconsole.log(this.type + &#39; can run&#39;)\n}\n\nfunction Dog(name, characteristic) {\n  this.name = name\n  this.characteristic = characteristic\n}\n\nDog.prototype = new Animal(&#39;Dog&#39;)   // 关键，重写原型对象\nDog.prototype.constructor = Dog     // 第一点，需要手动重写 constructor 指向\nDog.prototype.swim = function(){    // 第二点，子类添加属性和方法需要在替换原型之后\n\tconsole.log(this.name + &#39; can swim&#39;)\n}\n\nvar erha = new Dog(&#39;erha&#39;, &#39;fool&#39;)  // 第四点，无法向父类型的构造函数传参\nerha.childs.push(&#39;cat&#39;)             // 第三点，对于引用类型的修改\nconsole.log(erha.childs)            // [&quot;dog&quot;, &quot;cat&quot;]\nvar teddy = new Dog(&#39;teddy&#39;, &#39;cute&#39;)\nconsole.log(teddy.childs)           // [&quot;dog&quot;, &quot;cat&quot;]\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>从上面的例子可以看出，原型链继承有以下几个缺点：</p>\n<ul>\n<li>需要手动重写 <code>constructor</code> 属性</li>\n<li>子类添加属性和方法必须要在替换原型之后</li>\n<li>创建子类实例时无法向父类的构造函数传参</li>\n<li>最致命的一点是，某个实例对于原型上引用类型的数据进行修改会影响其他的实例</li>\n<li>存在属性遮蔽，如果子类的属性、方法跟父类命名一样，父类的属性或者方法只能通过 <code>__proto__</code> 来获取。</li>\n</ul>\n<h3 id=\"借用构造函数继承\"><a class=\"header-anchor\" href=\"#借用构造函数继承\" aria-hidden=\"true\">#</a> 借用构造函数继承</h3>\n<p>使用<strong>父类的构造函数</strong>来增强子类实例，等同于复制父类的实例给子类(不使用原型)。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>function Animal(type) {\n    this.name = &#39;animal&#39;\n    this.childs = [&#39;dog&#39;]\n    this.type = type\n}\n\nAnimal.prototype.run = function (){\n\tconsole.log(this.type + &#39; can run&#39;)\n}\n\nfunction Dog(type, name, characteristic) {\n  this.name = name\n  this.characteristic = characteristic\n  Animal.call(this, type)    // 这里是关键，调用父类的构造函数\n}\n\nvar erha = new Dog(&#39;dog&#39;, &#39;erha&#39;, &#39;fool&#39;)\nvar teddy = new Dog(&#39;dog&#39;, &#39;teddy&#39;, &#39;cute&#39;)\nerha.childs = [&#39;cat&#39;]\nconsole.log(erha.run)      // undefined\nconsole.log(teddy.childs)  // [&#39;dog&#39;]\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>从上面的例子可以看出</p>\n<ul>\n<li>子类只能继承父类的实例方法和属性，无法继承原型的方法和属性</li>\n<li>虽然解决了上面原型链继承对于引用类型修改会出现纂改的问题，但是无法实现复用，每个子类都有父类实例函数的副本，影响性能</li>\n</ul>\n<h3 id=\"组合继承\"><a class=\"header-anchor\" href=\"#组合继承\" aria-hidden=\"true\">#</a> 组合继承</h3>\n<p>用<strong>原型链</strong>来继承原型的方法和属性，用<strong>借用构造函数</strong>来实现实例属性的继承。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>function Animal(type) {\n  this.type = type\n  this.list = [1,2]\n  this.id = 1\n}\n\nAnimal.prototype.name = &#39;animal&#39;\nAnimal.prototype.run = function (){\n\tconsole.log(this.type + &#39; can run&#39;)\n}\n\nfunction Dog(type, name, characteristic) {\n  this.name = name\n  this.characteristic = characteristic\n  Animal.call(this, type)   // 实例属性和方法继承\n}\n\nDog.prototype = new Animal() //原型属性和方法继承\nDog.prototype.constructor = Dog\nDog.prototype.swim = function() {\n\treturn &#39;swim&#39;\n}\n\nvar erha = new Dog(&#39;dog&#39;, &#39;erha&#39;, &#39;fool&#39;)\nvar teddy = new Dog(&#39;dog&#39;, &#39;teddy&#39;, &#39;cute&#39;)\nerha.run() //dog can run\nerha.list.push(3)\nerha.list   // [1,2,3]\nteddy.list  // [1,2]\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>虽然目前可以复用原型链上的方法以及子类又有各自的属性，但是有个问题就是，父类的构造函数调用了两次，子类的原型(Dog.prototype)上也有一份父类实例属性的副本，而且这些属性会被子类实例(erha, teddy)的属性覆盖，即通过 erha.name 访问不到 Dog.prototype 的 name 属性，还是存在内存浪费。</p>\n<h3 id=\"原型式继承\"><a class=\"header-anchor\" href=\"#原型式继承\" aria-hidden=\"true\">#</a> 原型式继承</h3>\n<p>该方法最初由道格拉斯·克罗克福德于2006年在一篇题为 《Prototypal Inheritance in JavaScript》(JavaScript中的原型式继承) 的文章中提出。 他的想法是借助原型可以基于已有的对象创建新对象， 同时还不必因此创建自定义类型。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>function createObject(obj){\n  function F(){}\n  F.prototype = obj\n  return new F()\n}\n\n// 自定义对象作为原型\nvar person = {\n  name: &#39;user name&#39;,\n  friends: []\n}\n\nvar p1 = createObject(person)\np1.name = &#39;xiaoming&#39;\np1.idol = [&#39;lee&#39;]\np1.friends.push(&#39;xiaofeng&#39;)\nconsole.log(p1.friends) // [&quot;xiaofeng&quot;]\n\nvar p2 = createObject(person)\np2.name = &#39;xiaoqing&#39;\np2.idol = [&#39;vim&#39;]\np2.friends.push(&#39;xiaomin&#39;)\n\nconsole.log(p1.friends) // [&quot;xiaofeng&quot;, &quot;xiaomin&quot;]\nconsole.log(p2.friends) // [&quot;xiaofeng&quot;, &quot;xiaomin&quot;]\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>先看 createObject 函数，先是定义一个临时的构造函数 F()，把作为“原型”的对象 person 赋值给 F.prototype，接着返回 <code>new F()</code>，因为构造函数没有定义任何属性，所以返回一个空对象，这个对象的 <code>__proto__</code> 则指向“原型”对象，从而继承了“原型”对象 person 的属性。<br>\n从上面的列子可以看出，就是对于原型的引用类型进行修改会出现篡改的情况。<br>\n在 ECMAScript5 中，通过新增 Object.create() 方法规范化了上面的原型式继承。<br>\n用法：Object.create(proto[, propertiesObject])</p>\n<ul>\n<li>新创建对象的原型对象。</li>\n<li>可选。如果没有指定为 undefined，则是要添加到新创建对象的可枚举属性（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应Object.defineProperties()的第二个参数。</li>\n</ul>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>// 自定义对象作为原型\nvar person = {\n  name: &#39;user name&#39;,\n  friends: []\n}\nvar p1 = Object.create(person)\n</code></pre>\n<!--beforeend--></div><!--afterend--><h3 id=\"寄生式继承\"><a class=\"header-anchor\" href=\"#寄生式继承\" aria-hidden=\"true\">#</a> 寄生式继承</h3>\n<p>寄生式继承是与原型式继承紧密相关的一种思路， 同样是克罗克福德推而广之。<br>\n寄生式继承，即创建一个仅用于封装继承过程的函数，该函数内部以某种方法来增强对象，最后再像真的对它做了所有操作之后返回对象。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>function createAnother(original){\n  var clone = Object.create(original)  // 调用 Object.create 函数创建一个对象\n  clone.sayHi = function() {  // 以某种方法来增强对象\n    console.log(&#39;hi&#39;)\n  }\n\n  return clone   // 返回这个对象\n}\n\nvar person = {\n  name: &#39;user name&#39;,\n  friends: []\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><h3 id=\"寄生式组合继承\"><a class=\"header-anchor\" href=\"#寄生式组合继承\" aria-hidden=\"true\">#</a> 寄生式组合继承</h3>\n<p>结合借用构造函数<strong>传递参数</strong>和寄生模式实现继承。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>function inheritPrototype(subType, superType){\n  var prototype = Object.create(superType.prototype) // 创建对象，创建父类原型的一个副本\n  prototype.constructor = subType                    // 增强对象，弥补因重写原型而失去的默认的constructor 属性\n  subType.prototype = prototype                      // 指定对象，将新创建的对象赋值给子类的原型\n}\n\n// 父类初始化实例属性和原型属性\nfunction SuperType(name){\n  this.name = name\n  this.colors = [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;]\n}\nSuperType.prototype.sayName = function(){\n  alert(this.name)\n}\n\n\nfunction SubType(name, age){\n  SuperType.call(this, name)    // 借用构造函数传递增强子类实例属性（支持传参和避免篡改）\n  this.age = age\n}\n\n// 将子类原型指向父类\ninheritPrototype(SubType, SuperType)\n\n// 新增子类原型属性\nSubType.prototype.sayAge = function(){\n  alert(this.age)\n}\n\nvar instance1 = new SubType(&#39;xyc&#39;, 23)\nvar instance2 = new SubType(&#39;lxy&#39;, 23)\n\ninstance1.colors.push(&#39;2&#39;) // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;2&quot;]\ninstance2.colors.push(&#39;3&#39;) // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;3&quot;]\n</code></pre>\n<!--beforeend--></div><!--afterend--></div>\n",null]}
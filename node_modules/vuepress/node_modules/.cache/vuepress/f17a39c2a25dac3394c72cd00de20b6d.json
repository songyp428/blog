{"remainingRequest":"/Users/yanping/Documents/songyp/blog/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/yanping/Documents/songyp/blog/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/yanping/Documents/songyp/blog/docs/fe/js/prototype.md?vue&type=template&id=77d0645a&","dependencies":[{"path":"/Users/yanping/Documents/songyp/blog/docs/fe/js/prototype.md","mtime":1562666231000},{"path":"/Users/yanping/Documents/songyp/blog/node_modules/cache-loader/dist/cjs.js","mtime":1560934370000},{"path":"/Users/yanping/Documents/songyp/blog/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1560934372000},{"path":"/Users/yanping/Documents/songyp/blog/node_modules/cache-loader/dist/cjs.js","mtime":1560934370000},{"path":"/Users/yanping/Documents/songyp/blog/node_modules/vue-loader/lib/index.js","mtime":1560934372000},{"path":"/Users/yanping/Documents/songyp/blog/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1560934372000}],"contextDependencies":[],"result":["\n<div class=\"content\"><h3 id=\"原型和原型链\"><a class=\"header-anchor\" href=\"#原型和原型链\" aria-hidden=\"true\">#</a> 原型和原型链</h3>\n<ul>\n<li>什么是原型？为什么需要原型？</li>\n<li>原型链是什么？</li>\n<li>如何实现原型链？</li>\n</ul>\n<h4 id=\"构造函数\"><a class=\"header-anchor\" href=\"#构造函数\" aria-hidden=\"true\">#</a> 构造函数</h4>\n<p>构造函数: 使用 new 调用生成实例的函数。可以使用构造函数创建对象。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>function Idol(name) {\n    this.name = name\n}\n\nvar lee = new Idol(&#39;lee&#39;)\n</code></pre>\n<!--beforeend--></div><!--afterend--><h4 id=\"原型\"><a class=\"header-anchor\" href=\"#原型\" aria-hidden=\"true\">#</a> 原型</h4>\n<p>每一个函数都有 <code>prototype</code> 属性，函数的 <code>prototype</code> 指向一个对象。这个对象就是调用该构造函数创建的实例的原型。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>function Idol(name) {\n    this.name = name\n}\n\nIdol.prototype.type = &#39;idol&#39;\nIdol.prototype.skill = function () {\n    console.log(&#39;帅&#39;)\n}\n\nvar lee = new Idol(&#39;lee&#39;)\nvar vim = new Idol(&#39;vim&#39;)\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>从上面的例子看，Idol.prototype 就是实例 lee 和 vim 的原型。<br>\n那么原型到底是什么呢？每一个 JavaScript 对象（null 除外）在创建的时候就会与之关联另外一个对象，这个与之关联的对象就是原型。每一个对象从原型中“继承”属性。</p>\n<p>那么它们到底怎么关联的呢？</p>\n<h4 id=\"proto\"><a class=\"header-anchor\" href=\"#proto\" aria-hidden=\"true\">#</a> <code>__proto__</code></h4>\n<p>每一个 JavaScript 对象（null 除外）都具有一个属性 <code>__proto__</code>, 这个属性指向对象的原型。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>function Idol(name) {\n    this.name = name\n}\n\nvar lee = new Idol(&#39;lee&#39;)\nconsole.log(lee.__proto__  === Idol.prototype) // true\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>到目前为止，构造函数有一个属性 <code>prototype</code> 指向原型，实例有 <code>__proto__</code> 指向原型，那么原型是否也有属性构造函数和实例对象呢？</p>\n<h4 id=\"constructor\"><a class=\"header-anchor\" href=\"#constructor\" aria-hidden=\"true\">#</a> <code>constructor</code></h4>\n<p>原型指向实例对象的属性，其实也不必需要。原型都有一个属性 <code>constructor</code> 指向关联的构造函数。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>function Idol(name) {\n    this.name = name\n}\n\nconsole.log(Idol  === Idol.prototype.constructor) // true\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>那么这样子我们就可以得到了构造函数、原型和实例对象之间的关系。<br>\n通过上面的分析，我们可以得出三者的关系如下图：<br>\n<img src=\"https://raw.githubusercontent.com/songyp428/photo/master/ret/prototype1.png\" alt=\"Aaron Swartz\"></p>\n<h4 id=\"实例与原型\"><a class=\"header-anchor\" href=\"#实例与原型\" aria-hidden=\"true\">#</a> 实例与原型</h4>\n<p>我们着重来分析一下实例和原型的关系，实例是从原型上“继承”属性，那么怎么继承呢？\n先来看一下例子吧。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>function Idol(name) {\n    this.name = name\n}\n\nIdol.prototype.type = &#39;idol&#39;\n\nvar lee = new Idol(&#39;lee&#39;)\nconsole.log(lee.type)  // &#39;idol&#39;\n\nlee.type = &#39;actor&#39;\nconsole.log(lee.type)  // &#39;actor&#39;\n\ndelete lee.type\nconsole.log(lee.type)  // &#39;idol&#39;\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>从上面的例子可以看出，第一次打印 lee.type 的时候，虽然 lee 对象本身没有 type 属性，但是它的原型拥有 type 属性，lee “继承” 它的原型的 type 属性，所以第一次打印的结果是 idol；接下来我们给 lee 对象添加一个 type 属性，再打印一次 lee.name， 这时 lee 对象本身就有 type 属性，就不再去找原型上面找 type，打印结果为 actor；接下来我们删除了 lee 的 type 属性。这是 lee 本身没有 type 属性了，所以需要去原型上找，原型拥有 type 的属性，所以第三次的打印结果为 idol。<br>\n这里我们可以得出一个结论：优先访问实例中的属性，如果实例中没有的属性，则去原型上找。</p>\n<p>如果没有原型上没有找到相应的属性呢？</p>\n<h4 id=\"原型的原型\"><a class=\"header-anchor\" href=\"#原型的原型\" aria-hidden=\"true\">#</a> 原型的原型</h4>\n<p>其实原型也是一个对象，原型对象是通过 Object 构造函数生成，也就是说原型的 <code>__proto__</code> 指向 Object.prototype。\n这样子关系应该更新为\n<img src=\"https://raw.githubusercontent.com/songyp428/photo/master/ret/prototype2.png\" alt=\"Aaron Swartz\"></p>\n<p>那么 Object.prototype 的原型是什么呢？</p>\n<h4 id=\"原型链\"><a class=\"header-anchor\" href=\"#原型链\" aria-hidden=\"true\">#</a> 原型链</h4>\n<p>Object.prototype 的 <code>__prpro__</code> 指向 null。Object.prototype 是浏览器底层根据 ECMAScript 规范创造的一个对象。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>console.log(Object.prototype.__proto__ === null) // true\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>null 是表示缺少的标识，指示变量未指向任何对象。也就是说 Object.prototype 没有原型。<br>\n关系图更新为:\n<img src=\"https://raw.githubusercontent.com/songyp428/photo/master/ret/prototype3.png\" alt=\"Aaron Swartz\"></p>\n<p>那么原型链是什么呢？<br>\n每一个对象拥有一个原型对象，通过 <code>__proto__</code> 指针指向上一个原型 ，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 null。这种关系被称为原型链 (prototype chain)，通过原型链一个对象会拥有定义在其他对象中的属性和方法。也就是说原型链是基于 <code>__proto__</code> 实现。</p>\n<p>有个问题，你发现了吗？构造函数从何而来？</p>\n<h4 id=\"构造函数的原型链\"><a class=\"header-anchor\" href=\"#构造函数的原型链\" aria-hidden=\"true\">#</a> 构造函数的原型链</h4>\n<p>任何函数都是由 new Function 创建。也就是说所有的构造函数的 <code>__proto__</code> 都是指向 Function.prototype。<br>\nFunction.prototype 对象是一个函数（对象），其 [[Prototype]] 内部属性值指向内建对象 Object.prototype。Function.prototype 没有 prototype 属性。Function.prototype.<strong>proto</strong>  === Object.prototype。<br>\n那么关系图可以更新为:\n<img src=\"https://raw.githubusercontent.com/songyp428/photo/master/ret/prototype5.png\" alt=\"Aaron Swartz\"></p>\n<h4 id=\"总结\"><a class=\"header-anchor\" href=\"#总结\" aria-hidden=\"true\">#</a> 总结</h4>\n<ul>\n<li>每一个 JavaScript 对象（null 除外）在创建的时候就会与之关联另外一个对象，这个与之关联的对象就是<strong>原型</strong>。每一个对象从原型中“继承”属性。</li>\n<li>每一个对象拥有一个原型对象，通过 <code>__proto__</code> 指针指向上一个原型 ，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 null。这种关系被称为<strong>原型链</strong> (prototype chain)，通过原型链一个对象会拥有定义在其他对象中的属性和方法。也就是说原型链是基于 <code>__proto__</code> 实现。</li>\n</ul>\n</div>\n",null]}
{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{289:function(e,t,r){\"use strict\";r.r(t);var n=r(1),a=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,r=e._self._c||t;return r(\"div\",{staticClass:\"content\"},[r(\"h3\",{attrs:{id:\"数组去重\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#数组去重\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 数组去重\")]),e._v(\" \"),r(\"h4\",{attrs:{id:\"_1、双重循环\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1、双重循环\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 1、双重循环\")]),e._v(\" \"),r(\"blockquote\",[r(\"p\",[e._v(\"第一层循环是需要去重的 array\"),r(\"br\"),e._v(\"\\n第二层循环是存放没有重复的元素的临时 array (初始化为空数组)\"),r(\"br\"),e._v(\"\\n关键点我理解有两点：\"),r(\"br\"),e._v(\"\\n1、如果存在相等（ 全等哦，=== ）则跳出第二层循环\"),r(\"br\"),e._v(\"\\n2、如果第二层循环 index: j 的值与 tmpArr 的长度 length 相等，则存到 tmpArr\")])]),e._v(\" \"),r(\"p\",[r(\"strong\",[e._v(\"注意： 对象和 NaN 不去重。\")])]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"var a = [1, 1, 2, 3, 2, '1', true, '1', '2', 1, false, true, null, null, undefined, undefined, NaN, NaN]\\n\\nfunction getUniqueArray(arr){\\n\\tlet j\\n\\tlet tmp_len\\n\\tlet tmpArr = []\\n\\n\\tfor (let i = 0,len_i = arr.length; i < len_i; i++ ) {\\n\\t\\tfor (j = 0,tmp_len = tmpArr.length; j < tmp_len; j++ ) {\\n\\t\\t\\t//注意是 === \\n\\t\\t\\tif (arr[i] === tmpArr[j]) {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\n\\t\\t//j === tmp_len,则说明没有找到相同值\\n\\t\\tif (j === tmp_len) {\\n\\t\\t\\ttmpArr.push(arr[i])\\n\\t\\t}\\n\\t}\\n\\n\\treturn tmpArr\\n}\\n\\nconsole.log(getUniqueArray(a))  //[1, 2, 3, \\\"1\\\", true, \\\"2\\\", false, null, undefined, NaN, NaN]\\n\")])])]),r(\"h4\",{attrs:{id:\"_2、indexof-方法\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2、indexof-方法\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 2、indexOf 方法\")]),e._v(\" \"),r(\"blockquote\",[r(\"p\",[e._v(\"借助辅助数组，和 indexOf() 方法，循环一遍需要去重的数组，要执行 n 次 indexOf() 方法，如果数组很大，还是比较耗时。\")])]),e._v(\" \"),r(\"p\",[r(\"strong\",[e._v(\"注意：对象和 NaN 不去重。\")])]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"var a = [1, 1, 2, 3, 2, '1', true, '1', '2', 1, false, true, null, null, undefined, undefined, NaN, NaN]\\n\\nfunction getUniqueArray(arr) {\\n\\tvar tmpArr = []\\n\\n\\tfor (let i = 0,len = arr.length; i < len; i++) {\\n\\t\\t//关键点在这里\\n\\t\\tif (!(tmpArr.indexOf(arr[i]) > -1)) {\\n\\t\\t\\ttmpArr.push(arr[i])\\n\\t\\t}\\n\\t}\\n\\n\\treturn tmpArr\\n}\\n\\nconsole.log(getUniqueArray(a)) //[1, 2, 3, \\\"1\\\", true, \\\"2\\\", false, null, undefined, NaN, NaN]\\n\")])])]),r(\"h4\",{attrs:{id:\"_3、借助-object-键值对\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3、借助-object-键值对\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 3、借助 Object 键值对\")]),e._v(\" \"),r(\"blockquote\",[r(\"p\",[e._v(\"第一次写的时候，只是用元素本身作为 object 的 key，但是这样会导致一个问题，例如 1 和 ‘1’ 就是相同的 key,所以需要用元素数据类型和元素作为 key。\")])]),e._v(\" \"),r(\"p\",[r(\"strong\",[e._v(\"特别好，除了对象外都去重了\")])]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"var a = [1,1,'1',true,'1',1,false,true,null,null,undefined,undefined,NaN,NaN]\\n\\nfunction getUniqueArray(arr) {\\n\\tvar obj = {}\\n\\tvar tmpArr = []\\n\\n\\tfor (let i = 0,len = arr.length; i < len; i++) {\\n\\t\\tif (!obj.hasOwnProperty(typeof arr[i] + arr[i])) {\\n\\t\\t\\tobj[typeof arr[i] + arr[i]] = arr[i]\\n\\t\\t}\\n\\t}\\n\\n\\ttmpArr = Object.values(obj)\\n\\n\\treturn tmpArr\\n}\\n\\nconsole.log(getUniqueArray(a))  //[1, \\\"1\\\", true, false, null, undefined, NaN]\\n\\n\")])])]),r(\"h4\",{attrs:{id:\"_4、数组排序去重\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4、数组排序去重\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 4、数组排序去重\")]),e._v(\" \"),r(\"blockquote\",[r(\"p\",[e._v(\"先对需要去重的数组进行排序，如果循环已经排序好的数组，只需要比较当前元素和上一个元素是否相同就好。\"),r(\"br\"),e._v(\"\\n执行效率比使用 indexOf 方法要快。\"),r(\"br\"),e._v(\"\\n如果要求是去重，并且不改变元素本身的相对位置，这种方法就不适用了。\")])]),e._v(\" \"),r(\"p\",[r(\"strong\",[e._v(\"注意：对象和 NaN 不去重 数字 1 也不去重。\")])]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"//排序循环去重\\nvar a = [1,1,2,3,2,'1',true,'1','2',1,1,false,true,null,null,undefined,undefined,NaN,NaN]\\nfunction getUniqueArray(arr) {\\n\\t// var sortedArr = arr.concat().sort()  //copy,不修改原有数组\\n\\tvar sortedArr = JSON.parse(JSON.stringify(arr)).sort()  //copy,不修改原有数组\\n\\n\\tvar seen = sortedArr[0]   //赋值已排序数组的第一个元素作为seen\\n\\tvar tmpArr = [sortedArr[0]]\\n\\n\\tfor (var i = 1, len = sortedArr.length; i < len; i++) {\\n\\t\\tif(seen !== sortedArr[i]) {\\n\\t\\t\\ttmpArr.push(sortedArr[i])  //记录不重复的元素\\n\\t\\t\\tseen = sortedArr[i]        //更新新的seen\\n\\t\\t}\\n\\t}\\n\\n\\treturn tmpArr\\n}\\n\\nconsole.log(getUniqueArray(a))\\n\\n\")])])]),r(\"h4\",{attrs:{id:\"_5、利用-es5-的-filter-简化循环流程\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_5、利用-es5-的-filter-简化循环流程\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 5、利用 ES5 的 filter 简化循环流程\")]),e._v(\" \"),r(\"h5\",{attrs:{id:\"辅助-indexof-去重方法\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#辅助-indexof-去重方法\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 辅助 indexOf 去重方法\")]),e._v(\" \"),r(\"h4\",{attrs:{id:\"_6、借助-es6-一行代码去重\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_6、借助-es6-一行代码去重\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 6、借助 ES6 一行代码去重\")]),e._v(\" \"),r(\"blockquote\",[r(\"p\",[e._v(\"只针对一维数组，并且对象无法去重。\")])]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v('var a = [1,1,2,3,2,\\'1\\',true,\\'1\\',\\'2\\',1,1,false,true,null,null,undefined,undefined,NaN,NaN]\\nconsole.log([...new Set(a)])          //[1, 2, 3, \"1\", true, \"2\", false, null, undefined, NaN]\\nconsole.log(Array.from(new Set(a)))   //[1, 2, 3, \"1\", true, \"2\", false, null, undefined, NaN]\\n\\n')])])]),r(\"h4\",{attrs:{id:\"_7、数组元素为对象去重\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_7、数组元素为对象去重\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 7、数组元素为对象去重\")]),e._v(\" \"),r(\"blockquote\",[r(\"p\",[e._v(\"先来了解一下reduceRight\"),r(\"br\"),e._v(\"\\nreduceRight() : 从数组的末尾向前将数组中的数组项做累加。接收 callbackfn ( function callbackfn ( preValue, curValue, index, array ) ) 函数，而这个函数包含四个参数：\"),r(\"br\"),e._v(\" \"),r(\"strong\",[e._v(\"preValue\")]),e._v(\": 上一次调用回调返回的值，或者是提供的初始值（initialValue）。\\n\"),r(\"strong\",[e._v(\"curValue\")]),e._v(\": 数组中当前被处理的数组项。\"),r(\"br\"),e._v(\" \"),r(\"strong\",[e._v(\"index\")]),e._v(\": 当前数组项在数组中的索引值。\"),r(\"br\"),e._v(\" \"),r(\"strong\",[e._v(\"array\")]),e._v(\": 调用 reduce()方法的数组。\")])]),e._v(\" \"),r(\"blockquote\",[r(\"p\",[e._v(\"需要根据对象中唯一的 id 来作为唯一标示去重。初始值 initialValue 赋值为空数组（也就是 item 初始时为 [] )，然后判断当前处理元素的 id 是在辅助对象 hash 已有的 key ，不存在则 hash 增加这一条记录，并且把 curValue push 到 preValue 中。\")])]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"var a = [{id: 1,name: 'ss'},{id: 2,name: 's'},{id: 3,name: 'sss'},{id: 1,name: 'ss'},{id: 3,name: 'sss'},{id: 4,name: 'ssss'}]\\n\\nvar hash = {}\\nvar newArr = a.reduceRight((preValue, curValue) => {\\n    hash[curValue.id] ? '' : (hash[curValue.id] = true && preValue.push(curValue))\\n    return preValue\\n}, [])\\n\\nconsole.log(newArr)  //[{id: 4, name: \\\"ssss\\\"},{id: 3, name: \\\"sss\\\"},{id: 1, name: \\\"ss\\\"},{id: 2, name: \\\"s\\\"}]\\n\\n\")])])])])}],!1,null,null,null);a.options.__file=\"arrayDeduplication.md\";t.default=a.exports}}]);","extractedComments":[]}